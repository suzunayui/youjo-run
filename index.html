<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Youjo Run</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      /* Cozy pastel sky */
      background:
        radial-gradient(circle at 18% 12%, rgba(255,255,255,0.9) 0 120px, transparent 140px),
        radial-gradient(circle at 82% 18%, rgba(255,255,255,0.8) 0 160px, transparent 190px),
        radial-gradient(circle at 35% 30%, rgba(255,255,255,0.7) 0 110px, transparent 140px),
        radial-gradient(circle at 65% 38%, rgba(255,255,255,0.6) 0 140px, transparent 170px),
        radial-gradient(circle at 50% 10%, #f7fbff 0, #e7f2ff 40%, #d7e8ff 65%, #c8dcff 100%);
      font-family: "Segoe UI", sans-serif;
      color: #0f172a;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }
    body::after {
      /* Soft hills at bottom */
      content: "";
      position: fixed;
      left: -10vw;
      right: -10vw;
      bottom: -20vh;
      height: 50vh;
      background:
        radial-gradient(120% 100% at 10% 80%, #cfe8c9 0 55%, transparent 56%),
        radial-gradient(120% 100% at 55% 90%, #bfe0b8 0 60%, transparent 61%),
        radial-gradient(120% 100% at 95% 85%, #a9d2a2 0 58%, transparent 59%);
      opacity: 0.9;
      pointer-events: none;
      z-index: 0;
      filter: blur(2px);
    }
    header {
      padding: 12px 16px;
      background: linear-gradient(90deg, #0f172a, #1e293b);
      color: #e2e8f0;
      letter-spacing: 0.02em;
      font-weight: 600;
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    header .title { font-size: 18px; }
    header .actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #manual-btn {
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      background: rgba(147, 197, 253, 0.18);
      color: #e2e8f0;
      font-weight: 600;
      cursor: pointer;
      box-shadow: inset 0 0 0 1px rgba(147, 197, 253, 0.45);
    }
    #manual-btn:hover { background: rgba(147, 197, 253, 0.28); }
    #manual-btn:active { transform: translateY(1px); }
    #reset-score-btn {
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      background: rgba(239, 68, 68, 0.18);
      color: #e2e8f0;
      font-weight: 600;
      cursor: pointer;
      box-shadow: inset 0 0 0 1px rgba(239, 68, 68, 0.45);
    }
    #reset-score-btn:hover { background: rgba(239, 68, 68, 0.28); }
    #reset-score-btn:active { transform: translateY(1px); }
    main {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      padding: 12px;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }
    #stage-wrap {
      position: relative;
      width: 100%;
    }
    #stage {
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      background: linear-gradient(180deg, #e2f0ff 0%, #eef5ff 50%, #d7e6ff 100%);
      width: 100%;
      height: auto;
      display: block;
      aspect-ratio: 16 / 9;
      touch-action: none;
    }
    #panel {
      background: #0f172a;
      color: #e2e8f0;
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    #panel h2 { margin: 0 0 8px 0; font-size: 16px; color: #93c5fd; }
    #panel p { margin: 4px 0; font-size: 13px; line-height: 1.5; }
    code { background: rgba(255,255,255,0.08); padding: 2px 4px; border-radius: 4px; }
    #controls {
      position: absolute;
      left: 8px;
      right: 8px;
      bottom: 8px;
      display: none;
      justify-content: space-between;
      gap: 8px;
      pointer-events: auto;
    }
    #controls .pad, #controls .actions {
      display: flex;
      gap: 8px;
    }
    #controls button {
      width: 56px;
      height: 56px;
      border: none;
      border-radius: 14px;
      background: rgba(15, 23, 42, 0.85);
      color: #e2e8f0;
      font-weight: 700;
      letter-spacing: 0.02em;
      box-shadow: 0 6px 16px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      touch-action: none;
      user-select: none;
    }
    #controls button.active {
      background: #93c5fd;
      color: #0f172a;
      transform: translateY(1px);
    }
    /* Manual modal */
    #manual-modal {
      position: fixed;
      inset: 0;
      display: none;
      z-index: 1000;
    }
    #manual-modal.open { display: block; }
    #manual-modal .backdrop {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(2px);
    }
    #manual-modal .dialog {
      position: relative;
      margin: 8vh auto;
      width: min(520px, 92vw);
      background: #0f172a;
      color: #e2e8f0;
      border-radius: 12px;
      padding: 16px 18px 12px;
      box-shadow: 0 16px 48px rgba(0,0,0,0.5);
    }
    #manual-modal .dialog h2 {
      margin: 0 0 8px 0;
      font-size: 18px;
      color: #93c5fd;
    }
    #manual-modal .dialog p { margin: 6px 0; font-size: 14px; line-height: 1.6; }
    #manual-modal .close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      color: #e2e8f0;
      font-size: 20px;
      cursor: pointer;
    }
    @media (max-width: 900px) {
      main { grid-template-columns: 1fr; }
    }
    @media (hover: none), (pointer: coarse) {
      #controls { display: flex; }
      #panel p { font-size: 14px; }
      header { padding: 10px 12px; }
      #panel { display: none; }
      main {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 0;
        gap: 0;
        height: 100dvh;
      }
      #stage-wrap {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        min-height: 100dvh;
        padding-top: 52px; /* header space */
        padding-bottom: 110px; /* controls space */
        padding-left: 6px;
        padding-right: 6px;
        gap: 0;
      }
      #stage {
        width: 100%;
        height: auto;
        max-height: 100%;
      }
      #controls {
        bottom: calc(8px + env(safe-area-inset-bottom));
      }
      #controls button {
        width: 64px;
        height: 64px;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="title">Youjo Run</div>
    <div class="actions">
      <button id="reset-score-btn" type="button">„Éè„Ç§„Çπ„Ç≥„Ç¢„É™„Çª„ÉÉ„Éà</button>
      <button id="manual-btn" type="button" aria-haspopup="dialog" aria-controls="manual-modal">Ë™¨ÊòéÊõ∏</button>
    </div>
  </header>
  <main>
    <div id="stage-wrap">
      <canvas id="stage" width="960" height="540"></canvas>
      <div id="controls" aria-label="Touch controls">
        <div class="pad">
          <button id="btn-left" type="button" aria-label="Move left">‚óÄ</button>
          <button id="btn-right" type="button" aria-label="Move right">‚ñ∂</button>
        </div>
        <div class="actions">
          <button id="btn-jump" type="button" aria-label="Jump">Jump</button>
          <button id="btn-rotate" type="button" aria-label="Rotate">Rot</button>
          <button id="btn-sit" type="button" aria-label="Sit">Sit</button>
        </div>
      </div>
    </div>
  </main>

  <div id="manual-modal" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="manual-title">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="document">
      <button class="close" type="button" aria-label="Èñâ„Åò„Çã" data-close>√ó</button>
      <h2 id="manual-title">Êìç‰Ωú</h2>
      <p>A / ‚Üê: Â∑¶„Å´Ëµ∞„Çã</p>
      <p>D / ‚Üí: Âè≥„Å´Ëµ∞„Çã</p>
      <p>W / Space / ‚Üë: „Ç∏„É£„É≥„Éó</p>
      <p>S / ‚Üì: Â∫ß„ÇäÔºàÂ∫ß„Çã‚ÜíÂ∫ß„ÇäÂæÖÊ©üÔºâ</p>
      <p>„Åó„ÇÉ„Åå„ÇÄ„Å®„É≠„Ç±„ÉÉ„Éà„ÇíÂõûÈÅø„Åß„Åç„Åæ„Åô</p>
      <p>Z: ÂõûËª¢„É¢„Éº„Ç∑„Éß„É≥</p>
      <p>ÂõûËª¢„Åó„Å™„Åå„ÇâÂè≥„Å´ÁßªÂãï„Åô„Çã„Å®„Çπ„Ç≥„Ç¢„ÅåÂ¢ó„Åà„ÇÑ„Åô„Åè„Å™„Çã„Çà</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("stage");
    const ctx = canvas.getContext("2d");

    const frameSize = 256; // source frame size (px)
    const drawScale = 1.0;
    const drawSize = frameSize * drawScale;
    const screenCenterX = canvas.width * 0.5;
    let cameraX = 0;
    const animations = {
      idle:    { src: "spritesheets/idle_sheet.png",    frames: 194, cols: 14, fps: 18, loop: true },
      run:     { src: "spritesheets/run_sheet.png",     frames: 43,  cols: 7,  fps: 22, loop: true },
      jump:    { src: "spritesheets/jump_sheet.png",    frames: 51,  cols: 8,  fps: 30, loop: true }, // 2ÂÄçÈÄü
      rotate:  { src: "spritesheets/rotate_sheet.png",  frames: 47,  cols: 7,  fps: 20, loop: true },
      sit:     { src: "spritesheets/sit_sheet.png",     frames: 39,  cols: 7,  fps: 36, loop: false }, // Á¥Ñ2ÂÄçÈÄü
      sitting: { src: "spritesheets/sitting_sheet.png", frames: 58,  cols: 8,  fps: 12, loop: true },
      rotate:  { src: "spritesheets/rotate_sheet.png",  frames: 47,  cols: 7,  fps: 20, loop: true },
      sit:     { src: "spritesheets/sit_sheet.png",     frames: 39,  cols: 7,  fps: 36, loop: false },
      sitting: { src: "spritesheets/sitting_sheet.png", frames: 58,  cols: 8,  fps: 12, loop: true },
      sleep:   { src: "spritesheets/sleep_sheet.png",   frames: 65,  cols: 9,  fps: 12, loop: false },
    };

    const images = {};
    const keys = { left: false, right: false, jump: false, rotate: false, sit: false };
    const state = {
      action: "idle",
      facing: "left",
      x: canvas.width * 0.5,
      y: canvas.height - 120,
      vy: 0,
      onGround: true,
      frameIdx: 0,
      frameTime: 0,
    };

    let lastInputTime = performance.now();
    const idleSleepMs = 5000;

    let sleepStartTime = 0;
    let lastZzzSpawnTime = 0;
    const zzzSpawnMs = 1200;
    const sleepParticles = [];

    // Day/Night coin drain + exhaustion
    const dayPhaseMs = 20000;
    let dayNightOffsetMs = 0;
    let nightCount = 0;
    let wasNight = false;
    let debtAccumSec = 0;
    let deathReason = null; // "debt" | null
    let debtDeathActive = false;
    let debtSleepEndTime = 0;

    // Game state
    let maxDistanceX = state.x;
    let score = 0;
    let highScore = Number(localStorage.getItem("youjoRunHighScore") || "0");
    let gameOver = false;
    const obstacles = [];
    const kickedObstacles = [];
    const pits = [];
    let nextSpawnX = state.x + 600;
    let nextPitX = state.x + 1000;
    const killers = [];
    let nextKillerTime = performance.now() + 2500;
    const explosions = [];
    let gameOverTime = 0;
    let gameOverAwaitRelease = false;
    const maxHp = 3;
    const maxHpUnits = maxHp * 2;
    let hpUnits = maxHpUnits;
    let lastHitTime = 0;
    const invincibleMs = 900;

    const coins = [];
    let coinCount = 0;
    let nextCoinX = state.x + 400;

    // Jump handling (allow double jump)
    let jumpsUsed = 0; // 0 on ground, max 2 in air
    let prevJumpHeld = false;

    // Lollipop power-up: become giant and kick obstacles
    const lollipops = [];
    let nextLollipopX = state.x + 1800;
    let giantUntil = 0;
    const giantDurationMs = 5000;

    function restartGame() {
      gameOver = false;
      gameOverAwaitRelease = false;
      deathReason = null;
      debtAccumSec = 0;
      debtDeathActive = false;
      debtSleepEndTime = 0;

      // Reset player to a clean starting state.
      state.x = canvas.width * 0.5;
      state.y = groundY;
      state.vy = 0;
      state.onGround = true;
      state.facing = "left";
      jumpsUsed = 0;
      prevJumpHeld = false;
      cameraX = state.x - screenCenterX;

      obstacles.length = 0;
      kickedObstacles.length = 0;
      pits.length = 0;
      killers.length = 0;
      nextKillerTime = performance.now() + 2500;
      explosions.length = 0;
      nightCount = 0;
      // Restart always begins at daytime, and avoid immediate coin drain.
      dayNightOffsetMs = -(performance.now() % (dayPhaseMs * 2));
      wasNight = false;
      score = 0;
      maxDistanceX = state.x;
      hpUnits = maxHpUnits;
      lastHitTime = 0;
      coins.length = 0;
      coinCount = 0;
      lollipops.length = 0;
      giantUntil = 0;
      nextSpawnX = state.x + 600;
      nextPitX = state.x + 1000;
      nextCoinX = state.x + 400;
      nextLollipopX = state.x + 1800;
      lastInputTime = performance.now();
      setAction("idle");
    }

    function anyInputActive() {
      return keys.left || keys.right || keys.jump || keys.rotate || keys.sit;
    }

    function registerInput() {
      lastInputTime = performance.now();
    }

    const groundY = canvas.height - 80;
    const gravity = 1800; // px/s^2
    const moveSpeed = 320; // px/s
    const jumpVelocity = -600; // px/s (Â∞ë„ÅóÈ´ò„ÇÅ„Å´Ë™øÊï¥)

    function chromaKeyImage(img, key = [0, 255, 0], tolerance = 250, feather = 40, despill = 0.5) {
      // Replace near-key color with transparent + feather + green despill.
      const c = document.createElement("canvas");
      c.width = img.width;
      c.height = img.height;
      const cctx = c.getContext("2d");
      cctx.drawImage(img, 0, 0);
      const { data } = cctx.getImageData(0, 0, c.width, c.height);
      const tolSq = tolerance * tolerance;
      const softSq = (tolerance + feather) * (tolerance + feather);
      for (let i = 0; i < data.length; i += 4) {
        const dr = data[i] - key[0];
        const dg = data[i + 1] - key[1];
        const db = data[i + 2] - key[2];
        const distSq = dr * dr + dg * dg + db * db;
        if (distSq <= tolSq) {
          data[i + 3] = 0; // hard cut
        } else if (distSq <= softSq) {
          // feather alpha near the edge
          const t = (distSq - tolSq) / (softSq - tolSq);
          data[i + 3] = data[i + 3] * (1 - t);
        }
        // Despill: reduce green halo on remaining pixels.
        const r = data[i], g = data[i + 1], b = data[i + 2];
        const greenDominant = g > r * 1.2 && g > b * 1.2;
        if (greenDominant) {
          const maxOther = Math.max(r, b);
          const newG = Math.max(maxOther, g * (1 - despill));
          data[i + 1] = newG;
        }
      }
      const out = cctx.createImageData(c.width, c.height);
      out.data.set(data);
      cctx.putImageData(out, 0, 0);
      return c;
    }

    function loadImages() {
      return Promise.all(
        Object.entries(animations).map(([key, info]) => new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            images[key] = chromaKeyImage(img, [0, 255, 0], 80);
            resolve();
          };
          img.onerror = reject;
          img.src = info.src;
        }))
      );
    }

    function setAction(action) {
      if (state.action === action) return;
      state.action = action;
      state.frameIdx = 0;
      state.frameTime = 0;
    }

    function handleInput() {
      const movingLeft = keys.left && !keys.right;
      const movingRight = keys.right && !keys.left;

      if (movingLeft) state.facing = "left";
      else if (movingRight) state.facing = "right";

      // Sitting transition
      if (state.onGround && keys.sit && state.action !== "sit") {
        state.vy = 0;
        setAction("sit");
        return;
      }

      // While sit animation is playing, let it finish.
      if (state.action === "sit") return;

      // Sitting idle: break out when moving / jumping / rotating.
      if (state.action === "sitting") {
        if (keys.jump && state.onGround) {
          setAction("jump");
        } else if (keys.rotate && state.onGround) {
          setAction("rotate");
        } else if (movingLeft || movingRight) {
          setAction("run");
        } else {
          setAction("sitting");
        }
        return;
      }

      if (keys.rotate && state.onGround) {
        setAction("rotate");
        return;
      }

      if (!state.onGround) {
        setAction("jump");
        return;
      }

      if (movingLeft || movingRight) setAction("run");
      else setAction("idle");
    }

    function update(delta) {
      const now = performance.now();
      const hasInput = anyInputActive();
      if (hasInput) lastInputTime = now;

      // Day/Night transition handling (every 20s).
      const dayNightNow = now + dayNightOffsetMs;
      const isNightNow = (dayNightNow % (dayPhaseMs * 2)) >= dayPhaseMs;
      if (!wasNight && isNightNow) {
        nightCount += 1;
        const drain = Math.pow(2, nightCount); // 2,4,8,...
        coinCount -= drain;
      }
      wasNight = isNightNow;

      if (gameOver) {
        // Prevent instant restart if the player is holding a key.
        if (gameOverAwaitRelease) {
          if (!hasInput) gameOverAwaitRelease = false;
        } else if (hasInput && now - gameOverTime > 300) {
          restartGame();
        }
        return;
      }

      // Debt death sequence: play sleep animation, no input, then game over.
      if (debtDeathActive) {
        if (state.action !== "sleep") setAction("sleep");

        const anim = animations.sleep;
        const frameDuration = 1 / anim.fps;
        let reachedEnd = false;
        state.frameTime += delta;
        while (state.frameTime >= frameDuration) {
          state.frameTime -= frameDuration;
          if (state.frameIdx < anim.frames - 1) {
            state.frameIdx += 1;
          } else if (anim.loop) {
            state.frameIdx = 0;
          } else {
            reachedEnd = true;
          }
        }
        if (reachedEnd) {
          state.frameIdx = anim.frames - 1;
        }

        if (state.frameIdx >= anim.frames - 1) {
          if (debtSleepEndTime === 0) debtSleepEndTime = now;

          if (now - lastZzzSpawnTime >= zzzSpawnMs) {
            lastZzzSpawnTime = now;
            sleepParticles.push({
              text: "üí§",
              x: screenCenterX + (Math.random() - 0.5) * drawSize * 0.3,
              y: state.y - drawSize * 0.75,
              vx: (Math.random() - 0.5) * 10,
              vy: -20 - Math.random() * 20,
              born: now,
              life: 2200 + Math.random() * 600,
            });
            if (sleepParticles.length > 12) sleepParticles.shift();
          }
        }

        for (let i = sleepParticles.length - 1; i >= 0; i--) {
          const p = sleepParticles[i];
          const age = now - p.born;
          if (age >= p.life) {
            sleepParticles.splice(i, 1);
            continue;
          }
          p.x += p.vx * delta;
          p.y += p.vy * delta;
          p.vx *= 0.98;
        }

        if (debtSleepEndTime !== 0 && now - debtSleepEndTime >= 2000) {
          deathReason = "debt";
          gameOver = true;
          gameOverTime = now;
          gameOverAwaitRelease = true;
          if (score > highScore) {
            highScore = score;
            localStorage.setItem("youjoRunHighScore", String(highScore));
          }
        }
        return;
      }

      // Debt drain: while coinCount is negative, lose half a heart every 5 seconds.
      if (coinCount < 0) {
        debtAccumSec += delta;
        while (debtAccumSec >= 5) {
          debtAccumSec -= 5;
          hpUnits -= 1;
          if (hpUnits <= 0) {
            debtDeathActive = true;
            debtSleepEndTime = 0;
            sleepParticles.length = 0;
            lastZzzSpawnTime = now;
            setAction("sleep");
            state.frameIdx = 0;
            state.frameTime = 0;
            return;
          }
        }
      } else {
        debtAccumSec = 0;
      }

      // Sleep after 10s idle, only when grounded.
      if (state.action !== "sleep" && (now - lastInputTime) >= idleSleepMs && state.onGround) {
        setAction("sleep");
        sleepStartTime = now;
        lastZzzSpawnTime = now;
        sleepParticles.length = 0;
      }

      // While sleeping: animate to end, then hold last frame. Wake on input.
      if (state.action === "sleep") {
        const anim = animations[state.action];
        if (hasInput) {
          setAction("idle");
          sleepParticles.length = 0;
        } else {
          const frameDuration = 1 / anim.fps;
          let reachedEnd = false;
          state.frameTime += delta;
          while (state.frameTime >= frameDuration) {
            state.frameTime -= frameDuration;
            if (state.frameIdx < anim.frames - 1) {
              state.frameIdx += 1;
            } else if (anim.loop) {
              state.frameIdx = 0;
            } else {
              reachedEnd = true;
            }
          }
          if (reachedEnd) {
            state.frameIdx = anim.frames - 1;
          }

          // Spawn floating "zzz" once fully asleep.
          if (state.frameIdx >= anim.frames - 1 && now - lastZzzSpawnTime >= zzzSpawnMs) {
            lastZzzSpawnTime = now;
            sleepParticles.push({
              text: "üí§",
              x: screenCenterX + (Math.random() - 0.5) * drawSize * 0.3,
              y: state.y - drawSize * 0.75,
              vx: (Math.random() - 0.5) * 10,
              vy: -20 - Math.random() * 20,
              born: now,
              life: 2200 + Math.random() * 600,
            });
            if (sleepParticles.length > 12) sleepParticles.shift();
          }

          // Update particles
          for (let i = sleepParticles.length - 1; i >= 0; i--) {
            const p = sleepParticles[i];
            const age = now - p.born;
            if (age >= p.life) {
              sleepParticles.splice(i, 1);
              continue;
            }
            p.x += p.vx * delta;
            p.y += p.vy * delta;
            p.vx *= 0.98;
          }

          return;
        }
      }

      handleInput();

      if (state.action !== "sit") {
        if (keys.left && !keys.right) state.x -= moveSpeed * delta;
        else if (keys.right && !keys.left) state.x += moveSpeed * delta;
      }

      // World position is unbounded in both directions.
      cameraX = state.x - screenCenterX;

      const jumpPressed = keys.jump && !prevJumpHeld;
      prevJumpHeld = keys.jump;
      if (jumpPressed && jumpsUsed < 2) {
        jumpsUsed += 1;
        state.onGround = false;
        state.vy = jumpVelocity;
        setAction("jump");
      }

      const isOverPit = pits.some((p) => state.x >= p.x && state.x <= p.x + p.w);

      if (isOverPit && state.onGround) {
        state.onGround = false;
        state.vy = Math.max(0, state.vy);
      }

      if (!state.onGround) {
        state.vy += gravity * delta;
        state.y += state.vy * delta;
        if (!isOverPit && state.y >= groundY) {
          state.y = groundY;
          state.vy = 0;
          state.onGround = true;
          jumpsUsed = 0;
        }
      } else {
        if (!isOverPit) state.y = groundY;
        jumpsUsed = 0;
      }

      // Update score (distance to the right) and difficulty.
      if (state.x > maxDistanceX) {
        const dx = state.x - maxDistanceX;
        maxDistanceX = state.x;
        const spinBonus = state.action === "rotate" ? 4 : 1;
        score += Math.floor(dx * spinBonus);
      }

      const difficulty = Math.min(1, Math.max(0, (maxDistanceX - canvas.width * 0.5) / 6000));

      function adjustXForPits(x, w, buffer = 140) {
        let adjusted = x;
        for (const p of pits) {
          const pitStart = p.x - buffer;
          const pitEnd = p.x + p.w + buffer;
          const obStart = adjusted - w * 0.5;
          const obEnd = adjusted + w * 0.5;
          if (obEnd >= pitStart && obStart <= pitEnd) {
            adjusted = pitEnd + w * 0.5;
          }
        }
        return adjusted;
      }

      // Spawn pits ahead of the player while not sleeping.
      if (state.action !== "sleep") {
        while (maxDistanceX + canvas.width * 1.5 >= nextPitX) {
          const pitWidth = 140 + Math.random() * 220;
          pits.push({ x: nextPitX, w: pitWidth });
          const baseGap = 1200;
          const gap = baseGap + Math.random() * 1800 - difficulty * 500;
          nextPitX += Math.max(900, gap);
        }
      }

      // Spawn obstacles ahead of the player while not sleeping.
      // Avoid spawning close to pits.
      if (state.action !== "sleep") {
        while (maxDistanceX + canvas.width * 1.2 >= nextSpawnX) {
          const size = 48 + Math.random() * 18;
          const safeX = adjustXForPits(nextSpawnX, size);
          if (safeX !== nextSpawnX) {
            nextSpawnX = safeX;
            continue;
          }
          obstacles.push({
            x: nextSpawnX,
            w: size,
            h: size,
            emoji: Math.random() < 0.5 ? "ü™®" : "üåµ",
          });
          const baseGap = 320;
          const gap = baseGap + Math.random() * 380 - difficulty * 180;
          nextSpawnX += Math.max(220, gap);
        }
      }

      // Spawn flying "killer" bullets from the right.
      if (state.action !== "sleep" && now >= nextKillerTime) {
        const y = groundY - drawSize * (0.6 + Math.random() * 0.9);
        killers.push({
          // Spawn from the right edge of the screen (world coordinate).
          x: cameraX + canvas.width + 40 + Math.random() * 60,
          y,
          r: 30,
          vx: -(10 + difficulty * 5),   // start slow
          ax: -(260 + difficulty * 160), // accelerate
          maxVx: -(520 + difficulty * 260),
          emoji: "üöÄ",
        });
        const baseInterval = 4200;
        const interval = baseInterval + Math.random() * 3200 - difficulty * 1200;
        nextKillerTime = now + Math.max(2200, interval);
      }

      // Spawn coins ahead of the player while not sleeping.
      if (state.action !== "sleep") {
        while (maxDistanceX + canvas.width * 1.2 >= nextCoinX) {
          const inAir = Math.random() < 0.55;
          const coinY = inAir
            ? groundY - drawSize * (0.9 + Math.random() * 0.8)
            : groundY - drawSize * 0.25;
          coins.push({
            x: nextCoinX,
            y: coinY,
            r: 22,
            emoji: "üí∞",
          });
          const baseGap = 240;
          const gap = baseGap + Math.random() * 420 - difficulty * 140;
          nextCoinX += Math.max(160, gap);
        }
      }

      // Spawn lollipops (giant power-up) ahead of the player.
      if (state.action !== "sleep") {
        while (maxDistanceX + canvas.width * 1.2 >= nextLollipopX) {
          const lollyY = groundY - drawSize * (0.6 + Math.random() * 0.9);
          lollipops.push({
            x: nextLollipopX,
            y: lollyY,
            r: 28,
            emoji: "üç≠",
          });
          const baseGap = 1800;
          const gap = baseGap + Math.random() * 1800 - difficulty * 500;
          nextLollipopX += Math.max(1200, gap);
        }
      }

      // Remove obstacles far behind.
      for (let i = obstacles.length - 1; i >= 0; i--) {
        if (obstacles[i].x < state.x - canvas.width * 2) obstacles.splice(i, 1);
      }
      for (let i = pits.length - 1; i >= 0; i--) {
        if (pits[i].x + pits[i].w < state.x - canvas.width * 2) pits.splice(i, 1);
      }
      for (let i = killers.length - 1; i >= 0; i--) {
        if (killers[i].x < state.x - canvas.width * 2) killers.splice(i, 1);
      }
      for (let i = coins.length - 1; i >= 0; i--) {
        if (coins[i].x < state.x - canvas.width * 2) coins.splice(i, 1);
      }
      for (let i = lollipops.length - 1; i >= 0; i--) {
        if (lollipops[i].x < state.x - canvas.width * 2) lollipops.splice(i, 1);
      }

      // Update kicked obstacles (screen-space parabolic flight).
      for (let i = kickedObstacles.length - 1; i >= 0; i--) {
        const ko = kickedObstacles[i];
        ko.vy += 2200 * delta;
        ko.x += ko.vx * delta;
        ko.y += ko.vy * delta;
        ko.spin += ko.spinV * delta;
        if (ko.y > canvas.height + ko.size || ko.x < -ko.size * 2 || ko.x > canvas.width + ko.size * 2) {
          kickedObstacles.splice(i, 1);
        }
      }

      // Update killers movement.
      for (let i = killers.length - 1; i >= 0; i--) {
        const k = killers[i];
        if (typeof k.ax === "number") {
          k.vx = Math.max(k.maxVx, k.vx + k.ax * delta);
        }
        k.x += k.vx * delta;
      }

      // Update explosions
      for (let i = explosions.length - 1; i >= 0; i--) {
        if (now - explosions[i].born >= explosions[i].dur) explosions.splice(i, 1);
      }

      // Falling into pit -> game over.
      if (state.y > canvas.height + drawSize * 0.5) {
        gameOver = true;
        gameOverTime = now;
        gameOverAwaitRelease = true;
        if (score > highScore) {
          highScore = score;
          localStorage.setItem("youjoRunHighScore", String(highScore));
        }
        return;
      }

      // Coin pickup
      const isGiantNow = now < giantUntil;
      const charSizeNow = drawSize * (isGiantNow ? 2 : 1);
      const charTop = state.y - charSizeNow;
      const charBottom = state.y;
      for (let i = coins.length - 1; i >= 0; i--) {
        const c = coins[i];
        const cScreenX = c.x - cameraX;
        const nearX = Math.abs(cScreenX - screenCenterX) < (c.r + charSizeNow * 0.25);
        const nearY = c.y > charTop - c.r && c.y < charBottom + c.r;
        if (nearX && nearY) {
          coins.splice(i, 1);
          coinCount += 1;
          score += 50;
        }
      }

      // Lollipop pickup: giant for 5 seconds.
      for (let i = lollipops.length - 1; i >= 0; i--) {
        const l = lollipops[i];
        const lScreenX = l.x - cameraX;
        const nearX = Math.abs(lScreenX - screenCenterX) < (l.r + charSizeNow * 0.35);
        const nearY = l.y > charTop - l.r && l.y < charBottom + l.r;
        if (nearX && nearY) {
          lollipops.splice(i, 1);
          giantUntil = Math.max(giantUntil, now) + giantDurationMs;
        }
      }

      const isGiant = now < giantUntil;
      const isCrouching = state.onGround && (state.action === "sit" || state.action === "sitting");

      // Collision: simple ground hitbox with HP + i-frames, or kick obstacles while giant.
      if (state.action !== "sleep" && state.onGround && state.action !== "jump") {
        if (isGiant) {
          for (let i = obstacles.length - 1; i >= 0; i--) {
            const ob = obstacles[i];
            const obScreenX = ob.x - cameraX;
            const nearX = Math.abs(obScreenX - screenCenterX) < (ob.w * 0.85);
            if (nearX) {
              obstacles.splice(i, 1);
              score += 20;
              const dir = state.facing === "right" ? 1 : -1;
              kickedObstacles.push({
                emoji: ob.emoji,
                size: ob.w,
                x: screenCenterX,
                y: groundY - ob.w * 0.3,
                vx: dir * (520 + Math.random() * 180),
                vy: -(780 + Math.random() * 220),
                spin: 0,
                spinV: dir * (5 + Math.random() * 4),
              });
            }
          }
        } else if (now - lastHitTime >= invincibleMs) {
          for (let i = 0; i < obstacles.length; i++) {
            const ob = obstacles[i];
            const obScreenX = ob.x - cameraX;
            const nearX = Math.abs(obScreenX - screenCenterX) < (ob.w * 0.55);
            if (nearX) {
              hpUnits -= 2;
              lastHitTime = now;
              obstacles.splice(i, 1); // remove hit obstacle
              if (hpUnits <= 0) {
                gameOver = true;
                gameOverTime = now;
                gameOverAwaitRelease = true;
                if (score > highScore) {
                  highScore = score;
                  localStorage.setItem("youjoRunHighScore", String(highScore));
                }
              }
              break;
            }
          }
        }
      }

      // Killer collision: avoidable by crouching. While giant, kick them away.
      if (state.action !== "sleep" && !isCrouching) {
        if (isGiant) {
          for (let i = killers.length - 1; i >= 0; i--) {
            const k = killers[i];
            const kScreenX = k.x - cameraX;
            const nearX = Math.abs(kScreenX - screenCenterX) < (k.r + charSizeNow * 0.35);
            const nearY = k.y > charTop - k.r && k.y < charBottom + k.r;
            if (nearX && nearY) {
              killers.splice(i, 1);
              const dir = state.facing === "right" ? 1 : -1;
              kickedObstacles.push({
                emoji: k.emoji,
                size: k.r * 2,
                x: screenCenterX,
                y: k.y,
                vx: dir * (640 + Math.random() * 220),
                vy: -(820 + Math.random() * 260),
                spin: 0,
                spinV: dir * (6 + Math.random() * 5),
              });
              score += 15;
            }
          }
        } else if (now - lastHitTime >= invincibleMs) {
          for (let i = 0; i < killers.length; i++) {
            const k = killers[i];
            const kScreenX = k.x - cameraX;
            const nearX = Math.abs(kScreenX - screenCenterX) < (k.r + charSizeNow * 0.25);
            const nearY = k.y > charTop - k.r && k.y < charBottom + k.r;
            if (nearX && nearY) {
              killers.splice(i, 1);
              explosions.push({
                x: screenCenterX,
                y: k.y,
                born: now,
                dur: 2000,
              });
              hpUnits -= 2;
              lastHitTime = now;
              if (hpUnits <= 0) {
                gameOver = true;
                gameOverTime = now;
                gameOverAwaitRelease = true;
                if (score > highScore) {
                  highScore = score;
                  localStorage.setItem("youjoRunHighScore", String(highScore));
                }
              }
              break;
            }
          }
        }
      }

      const anim = animations[state.action];
      const frameDuration = 1 / anim.fps;
      let reachedEnd = false;
      state.frameTime += delta;
      while (state.frameTime >= frameDuration) {
        state.frameTime -= frameDuration;
        if (state.frameIdx < anim.frames - 1) {
          state.frameIdx += 1;
        } else if (anim.loop) {
          state.frameIdx = 0;
        } else {
          reachedEnd = true;
        }
      }

      if (reachedEnd) {
        state.frameIdx = anim.frames - 1;
        if (state.action === "sit") {
          setAction("sitting");
        }
      }
    }

    function drawBackground(camX) {
      const nowMs = performance.now();
      const dayNightNow = nowMs + dayNightOffsetMs;
      const isNight = (dayNightNow % (dayPhaseMs * 2)) >= dayPhaseMs;

      // Cozy pastel sky (day/night)
      const sky = ctx.createLinearGradient(0, 0, 0, groundY);
      if (isNight) {
        sky.addColorStop(0, "#0b1020");
        sky.addColorStop(0.6, "#141a33");
        sky.addColorStop(1, "#1a2140");
      } else {
        sky.addColorStop(0, "#f7fbff");
        sky.addColorStop(0.6, "#e8f2ff");
        sky.addColorStop(1, "#d7e8ff");
      }
      ctx.fillStyle = sky;
      ctx.fillRect(0, 0, canvas.width, groundY);

      // Sun / Moon (emoji) with soft glow
      // Place sun/moon near the HP hearts (top-right).
      const heartSize = Math.round(canvas.width * 0.035 + 10);
      const heartsWidth = heartSize * maxHp;
      const sunR = canvas.width * 0.055;
      const sunX = canvas.width - 12 - heartsWidth - heartSize - sunR * 1.15;
      const sunY = 8 + heartSize * 1.05;
      const sunGlow = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR);
      if (isNight) {
        sunGlow.addColorStop(0, "rgba(210, 225, 255, 0.7)");
        sunGlow.addColorStop(1, "rgba(210, 225, 255, 0)");
      } else {
        sunGlow.addColorStop(0, "rgba(255, 245, 200, 0.9)");
        sunGlow.addColorStop(1, "rgba(255, 245, 200, 0)");
      }
      ctx.fillStyle = sunGlow;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
      ctx.fill();
      ctx.font = `${Math.round(sunR * 1.6)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(isNight ? "üåô" : "üåû", sunX, sunY);

      const wrapX = (x, span) => ((x % span) + span) % span;

      // Soft clouds (emoji, slow parallax)
      const cloudSize = canvas.width * 0.08;
      ctx.font = `${Math.round(cloudSize)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const clouds = [
        { x: 0.30, y: 0.18, e: "‚òÅÔ∏è", s: 1.0 },
        { x: 0.70, y: 0.22, e: "‚òÅÔ∏è", s: 1.1 },
        { x: 0.50, y: 0.32, e: "‚òÅÔ∏è", s: 0.95 },
      ];
      for (const c of clouds) {
        const span = canvas.width;
        const baseX = canvas.width * c.x;
        const cxWrapped = wrapX(baseX - camX * 0.3, span);
        const cy = canvas.height * c.y;
        for (const offset of [0, -span]) {
          const cx = cxWrapped + offset;
          ctx.save();
          ctx.translate(cx, cy);
          ctx.scale(c.s, c.s);
          ctx.fillText(c.e, 0, 0);
          ctx.restore();
        }
      }

      // Gentle hills (medium parallax), infinite tiling.
      const hillFactor = 0.5;
      const hillStep = canvas.width;
      const hillViewLeft = camX * hillFactor - hillStep * 2;
      const hillViewRight = camX * hillFactor + canvas.width + hillStep * 2;
      const hillFirst = Math.floor(hillViewLeft / hillStep);
      const hillLast = Math.ceil(hillViewRight / hillStep);
      ctx.fillStyle = "#cfe8c9";
      ctx.beginPath();
      const hillDefs = [
        { x: 0.15, y: 30, rx: 0.35, ry: 0.22 },
        { x: 0.60, y: 40, rx: 0.45, ry: 0.25 },
        { x: 1.05, y: 35, rx: 0.40, ry: 0.23 },
      ];
      for (let k = hillFirst; k <= hillLast; k++) {
        const tileOffset = k * hillStep - camX * hillFactor;
        for (const h of hillDefs) {
          const baseX = canvas.width * h.x;
          const rx = canvas.width * h.rx;
          const ry = canvas.height * h.ry;
          ctx.ellipse(baseX + tileOffset, groundY + h.y, rx, ry, 0, 0, Math.PI * 2);
        }
      }
      ctx.fill();

      const mod = (n, m) => ((n % m) + m) % m;

      // Tree line on the horizon (emoji, medium-fast parallax), stable tiling.
      const treeFactor = 0.6;
      const treeY = groundY - canvas.height * 0.12;
      const treeSize = canvas.width * 0.09;
      ctx.font = `${Math.round(treeSize)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      const trees = ["üå≥", "üå≤", "üå≥", "üå≤", "üå≥"];
      const treeStep = canvas.width * 0.22;
      const treeViewLeft = camX * treeFactor - treeStep * 3;
      const treeViewRight = camX * treeFactor + canvas.width + treeStep * 3;
      const treeFirst = Math.floor(treeViewLeft / treeStep);
      const treeLast = Math.ceil(treeViewRight / treeStep);
      for (let i = treeFirst; i <= treeLast; i++) {
        const tx = i * treeStep - camX * treeFactor;
        ctx.fillText(trees[mod(i, trees.length)], tx, treeY);
      }

      // Ground decorations (emoji, moves with ground), stable tiling.
      const decoFactor = 1.0;
      const decoY = groundY + canvas.height * 0.06;
      const decoSize = canvas.width * 0.045;
      ctx.font = `${Math.round(decoSize)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const decos = ["üåø", "‚òòÔ∏è", "üçÄ", "üåæ", "üå±"];
      const decoStep = canvas.width * 0.14;
      const decoViewLeft = camX * decoFactor - decoStep * 3;
      const decoViewRight = camX * decoFactor + canvas.width + decoStep * 3;
      const decoFirst = Math.floor(decoViewLeft / decoStep);
      const decoLast = Math.ceil(decoViewRight / decoStep);
      for (let i = decoFirst; i <= decoLast; i++) {
        const dx = i * decoStep - camX * decoFactor;
        ctx.fillText(decos[mod(i, decos.length)], dx, decoY);
      }

      // Ground / platform
      const grass = ctx.createLinearGradient(0, groundY, 0, canvas.height);
      grass.addColorStop(0, "#9ad29a");
      grass.addColorStop(1, "#6fbf7a");
      ctx.fillStyle = grass;
      ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

      // Horizon line / ground edge for readability.
      ctx.fillStyle = "rgba(15, 23, 42, 0.35)";
      ctx.fillRect(0, groundY, canvas.width, 10);
      ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
      ctx.fillRect(0, groundY + 10, canvas.width, 3);

      if (isNight) {
        ctx.save();
        ctx.fillStyle = "rgba(5, 10, 20, 0.35)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        // Small twinkling stars
        const starCount = 18;
        ctx.font = `${Math.round(canvas.width * 0.03)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.globalAlpha = 0.9;
        for (let i = 0; i < starCount; i++) {
          const sx = (i * 173 + nowMs * 0.02) % canvas.width;
          const sy = (i * 97) % (groundY * 0.9);
          const twinkle = 0.5 + 0.5 * Math.sin(nowMs / 700 + i);
          ctx.globalAlpha = 0.25 + twinkle * 0.6;
          ctx.fillText("‚ú®", sx, sy);
        }
        ctx.restore();
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground(cameraX);

      // Obstacles
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "alphabetic";
      for (const ob of obstacles) {
        const x = ob.x - cameraX;
        if (x < -ob.w || x > canvas.width + ob.w) continue;
        const size = ob.w;
        const y = groundY + size * 0.1;
        // Draw emoji with solid outline/shadow so it stays readable without translucency.
        ctx.save();
        ctx.font = `${Math.round(size)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
        ctx.shadowColor = "rgba(0,0,0,1)";
        ctx.shadowBlur = 6;
        ctx.shadowOffsetY = 3;
        ctx.lineWidth = 6;
        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.strokeText(ob.emoji, x, y);
        ctx.fillText(ob.emoji, x, y);
        ctx.restore();
      }
      ctx.restore();

      // Kicked obstacles (flying arcs)
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (const ko of kickedObstacles) {
        ctx.save();
        ctx.translate(ko.x, ko.y);
        ctx.rotate(ko.spin);
        ctx.font = `${Math.round(ko.size)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
        ctx.shadowColor = "rgba(0,0,0,1)";
        ctx.shadowBlur = 5;
        ctx.shadowOffsetY = 2;
        ctx.lineWidth = 4;
        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.strokeText(ko.emoji, 0, 0);
        ctx.fillText(ko.emoji, 0, 0);
        ctx.restore();
      }
      ctx.restore();

      // Killers (flying from right)
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (const k of killers) {
        const x = k.x - cameraX;
        if (x < -k.r || x > canvas.width + k.r) continue;
        ctx.save();
        ctx.translate(x, k.y);
        // Rotate clockwise 225deg (no mirroring).
        ctx.rotate(5 * Math.PI / 4);
        ctx.font = `${Math.round(k.r * 2.2)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
        ctx.shadowColor = "rgba(0,0,0,1)";
        ctx.shadowBlur = 5;
        ctx.shadowOffsetY = 2;
        ctx.lineWidth = 4;
        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.strokeText(k.emoji, 0, 0);
        ctx.fillText(k.emoji, 0, 0);
        ctx.restore();
      }
      ctx.restore();

      // Explosions
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (const ex of explosions) {
        const age = performance.now() - ex.born;
        const t = Math.min(1, Math.max(0, age / ex.dur));
        // Pulse for ~2s: big<->small a few times, then fade out.
        const pulses = 4;
        const pulse = 0.5 + 0.5 * Math.sin(t * Math.PI * 2 * pulses);
        const scale = 0.8 + pulse * 0.9;
        const size = Math.round(canvas.width * 0.18 * scale);
        const alpha = Math.max(0, 1 - t * 0.9);

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font = `${size}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
        ctx.shadowColor = "rgba(0,0,0,0.8)";
        ctx.shadowBlur = 16;
        ctx.shadowOffsetY = 6;
        ctx.fillText("üí•", ex.x, ex.y);
        ctx.restore();
      }
      ctx.restore();

      // Pits (draw gaps in ground)
      ctx.save();
      for (const p of pits) {
        const x0 = p.x - cameraX;
        const x1 = x0 + p.w;
        if (x1 < -20 || x0 > canvas.width + 20) continue;
        ctx.fillStyle = "rgba(78, 52, 33, 0.9)";
        ctx.fillRect(x0, groundY + 2, p.w, canvas.height - groundY);
        ctx.fillStyle = "rgba(255, 255, 255, 0.08)";
        ctx.fillRect(x0, groundY + 2, p.w, 6);
      }
      ctx.restore();

      // Lollipops
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (const l of lollipops) {
        const x = l.x - cameraX;
        if (x < -l.r || x > canvas.width + l.r) continue;
        ctx.font = `${Math.round(l.r * 2.2)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
        ctx.shadowColor = "rgba(0,0,0,1)";
        ctx.shadowBlur = 5;
        ctx.shadowOffsetY = 2;
        ctx.lineWidth = 4;
        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.strokeText(l.emoji, x, l.y);
        ctx.fillText(l.emoji, x, l.y);
      }
      ctx.restore();

      // Coins
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (const c of coins) {
        const x = c.x - cameraX;
        if (x < -c.r || x > canvas.width + c.r) continue;
        ctx.font = `${Math.round(c.r * 2.2)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
        ctx.shadowColor = "rgba(0,0,0,1)";
        ctx.shadowBlur = 4;
        ctx.shadowOffsetY = 2;
        ctx.lineWidth = 4;
        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.strokeText(c.emoji, x, c.y);
        ctx.fillText(c.emoji, x, c.y);
      }
      ctx.restore();

      // HUD
      ctx.save();
      const hudNow = performance.now() + dayNightOffsetMs;
      const isNightHud = (hudNow % (dayPhaseMs * 2)) >= dayPhaseMs;
      ctx.fillStyle = isNightHud ? "rgba(255, 255, 255, 0.95)" : "rgba(15, 23, 42, 0.9)";
      ctx.font = `${Math.round(canvas.width * 0.02 + 12)}px sans-serif`;
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      const daysSurvived = nightCount;
      const nextPayment = Math.pow(2, nightCount + 1); // 2,4,8,...
      const x = 12;
      const y = 10;
      const lineH = Math.round(canvas.width * 0.02 + 18);
      ctx.fillText(`Ë∑ùÈõ¢: ${Math.max(0, score)}  /  „Éè„Ç§„Çπ„Ç≥„Ç¢: ${highScore}`, x, y);
      ctx.fillText(`„Åä„Åã„Å≠: ${coinCount}  /  Ê¨°Âõû„ÅÆÊîØÊâïÈ°ç: ${nextPayment}`, x, y + lineH);
      ctx.fillText(`ÁîüÂ≠òÊó•Êï∞: ${daysSurvived}`, x, y + lineH * 2);

      // HP hearts (top-right)
      const heartSize = Math.round(canvas.width * 0.035 + 10);
      ctx.font = `${heartSize}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
      ctx.textAlign = "right";
      const hpUnitsClamped = Math.max(0, Math.min(maxHpUnits, hpUnits));
      const fullHearts = Math.floor(hpUnitsClamped / 2);
      const halfHeart = hpUnitsClamped % 2;
      const emptyHearts = Math.max(0, maxHp - fullHearts - halfHeart);
      const hearts = "‚ù§Ô∏è".repeat(fullHearts) + (halfHeart ? "üíî" : "") + "ü§ç".repeat(emptyHearts);
      ctx.fillText(hearts, canvas.width - 12, 8);

      ctx.restore();

      const anim = animations[state.action];
      const img = images[state.action];
      if (!img) return;

      const col = state.frameIdx % anim.cols;
      const row = Math.floor(state.frameIdx / anim.cols);
      const sx = col * frameSize;
      const sy = row * frameSize;
      const nowMs = performance.now();
      const isGiant = nowMs < giantUntil;
      const giantScale = isGiant ? 2 : 1;
      const drawSizeNow = drawSize * giantScale;
      const dx = screenCenterX - drawSizeNow * 0.5;
      const dy = state.y - drawSizeNow;

      ctx.save();
      if (isGiant) {
        ctx.globalAlpha = 0.98;
        ctx.shadowColor = "rgba(255, 180, 220, 0.9)";
        ctx.shadowBlur = 20;
      }
      if (state.facing === "right") {
        ctx.translate(dx + drawSizeNow, dy);
        ctx.scale(-1, 1);
        ctx.drawImage(img, sx, sy, frameSize, frameSize, 0, 0, drawSizeNow, drawSizeNow);
      } else {
        ctx.translate(dx, dy);
        ctx.drawImage(img, sx, sy, frameSize, frameSize, 0, 0, drawSizeNow, drawSizeNow);
      }
      ctx.restore();

      // Sleep text effects
      if (state.action === "sleep") {
        const anim = animations.sleep;
        const progress = anim.frames > 1 ? state.frameIdx / (anim.frames - 1) : 1;

        // "„Åô„ÇÑ„ÅÅ„Éª„Éª„Éª" appears around frame 30, then fades out to the end.
        const suyaaStartFrame = 30;
        if (state.frameIdx >= suyaaStartFrame && state.frameIdx < anim.frames - 1) {
          const tSuyaa = (state.frameIdx - suyaaStartFrame) / (anim.frames - 1 - suyaaStartFrame);
          const alpha = Math.max(0, 1 - tSuyaa);
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.fillStyle = "rgba(15, 23, 42, 0.9)";
          ctx.font = `${Math.round(canvas.width * 0.04)}px sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "bottom";
          const ty = state.y - drawSize * 1.05 - tSuyaa * 20;
          ctx.fillText("„Åô„ÇÑ„ÅÅ„Éª„Éª„Éª", screenCenterX, ty);
          ctx.restore();
        }

        // Floating "zzz"
        ctx.save();
        ctx.fillStyle = "rgba(15, 23, 42, 0.9)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (const p of sleepParticles) {
          const age = performance.now() - p.born;
          const t = Math.min(1, age / p.life);
          const a = 1 - t;
          ctx.globalAlpha = a;
          ctx.font = `${Math.round(canvas.width * 0.05 * (1 + t * 0.25))}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
          ctx.fillText(p.text, p.x, p.y);
        }
        ctx.restore();
      }

      if (gameOver) {
        ctx.save();
        ctx.fillStyle = "rgba(15, 23, 42, 0.55)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = `bold ${Math.round(canvas.width * 0.05)}px sans-serif`;
        const gameOverTitle = deathReason === "debt" ? "„Åä„Åã„Å≠„Åå„Å™„ÅÑ„ÄÅ„ÇÇ„ÅØ„ÇÑ„Åì„Çå„Åæ„Åß„Éª„Éª„Éª" : "GAME OVER";
        ctx.fillText(gameOverTitle, screenCenterX, canvas.height * 0.45);
        ctx.font = `${Math.round(canvas.width * 0.03)}px sans-serif`;
        ctx.fillText("„Çø„ÉÉ„Éó / Space „ÅßÂÜçÈñã", screenCenterX, canvas.height * 0.55);
        ctx.restore();
      }
    }

    let lastTime = performance.now();
    function loop(time) {
      const delta = Math.min(0.05, (time - lastTime) / 1000);
      lastTime = time;
      update(delta);
      draw();
      requestAnimationFrame(loop);
    }

    window.addEventListener("keydown", (e) => {
      registerInput();
      if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = true;
      if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = true;
      if (e.code === "Space" || e.code === "KeyW" || e.code === "ArrowUp") { keys.jump = true; e.preventDefault(); }
      if (e.code === "KeyZ") keys.rotate = true;
      if (e.code === "KeyS" || e.code === "ArrowDown") keys.sit = true;
    });
    window.addEventListener("keyup", (e) => {
      if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = false;
      if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = false;
      if (e.code === "Space" || e.code === "KeyW" || e.code === "ArrowUp") keys.jump = false;
      if (e.code === "KeyZ") keys.rotate = false;
      if (e.code === "KeyS" || e.code === "ArrowDown") keys.sit = false;
    });

    function bindTouchButton(buttonId, keyName) {
      const btn = document.getElementById(buttonId);
      if (!btn) return;

      const down = (e) => {
        e.preventDefault();
        registerInput();
        keys[keyName] = true;
        btn.classList.add("active");
        try { btn.setPointerCapture(e.pointerId); } catch {}
      };
      const up = (e) => {
        e.preventDefault();
        keys[keyName] = false;
        btn.classList.remove("active");
        try { btn.releasePointerCapture(e.pointerId); } catch {}
      };

      btn.addEventListener("pointerdown", down);
      btn.addEventListener("pointerup", up);
      btn.addEventListener("pointercancel", up);
      btn.addEventListener("pointerleave", up);
      btn.addEventListener("lostpointercapture", up);
    }

    bindTouchButton("btn-left", "left");
    bindTouchButton("btn-right", "right");
    bindTouchButton("btn-jump", "jump");
    bindTouchButton("btn-rotate", "rotate");
    bindTouchButton("btn-sit", "sit");

    canvas.addEventListener("pointerdown", (e) => {
      if (gameOver) {
        e.preventDefault();
        restartGame();
      }
    });

    const manualBtn = document.getElementById("manual-btn");
    const manualModal = document.getElementById("manual-modal");
    const resetScoreBtn = document.getElementById("reset-score-btn");
    const closeManual = () => {
      if (!manualModal) return;
      manualModal.classList.remove("open");
      manualModal.setAttribute("aria-hidden", "true");
    };
    const openManual = () => {
      if (!manualModal) return;
      manualModal.classList.add("open");
      manualModal.setAttribute("aria-hidden", "false");
      manualModal.querySelector(".close")?.focus();
    };
    manualBtn?.addEventListener("click", openManual);
    resetScoreBtn?.addEventListener("click", () => {
      highScore = 0;
      localStorage.setItem("youjoRunHighScore", "0");
    });
    manualModal?.addEventListener("click", (e) => {
      const target = e.target;
      if (target instanceof HTMLElement && target.hasAttribute("data-close")) {
        closeManual();
      }
    });
    window.addEventListener("keydown", (e) => {
      if (e.code === "Escape" && manualModal?.classList.contains("open")) closeManual();
    });

    window.addEventListener("blur", () => {
      keys.left = keys.right = keys.jump = keys.rotate = keys.sit = false;
      document.querySelectorAll("#controls button").forEach((b) => b.classList.remove("active"));
    });

    loadImages()
      .then(() => requestAnimationFrame(loop))
      .catch((err) => {
        ctx.fillStyle = "#ef4444";
        ctx.font = "20px sans-serif";
        ctx.fillText("ÁîªÂÉè„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: " + err, 20, 40);
        console.error(err);
      });
  </script>
</body>
</html>
