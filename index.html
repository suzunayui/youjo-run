<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Sprite Runner</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      /* Cozy pastel sky */
      background:
        radial-gradient(circle at 18% 12%, rgba(255,255,255,0.9) 0 120px, transparent 140px),
        radial-gradient(circle at 82% 18%, rgba(255,255,255,0.8) 0 160px, transparent 190px),
        radial-gradient(circle at 35% 30%, rgba(255,255,255,0.7) 0 110px, transparent 140px),
        radial-gradient(circle at 65% 38%, rgba(255,255,255,0.6) 0 140px, transparent 170px),
        radial-gradient(circle at 50% 10%, #f7fbff 0, #e7f2ff 40%, #d7e8ff 65%, #c8dcff 100%);
      font-family: "Segoe UI", sans-serif;
      color: #0f172a;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }
    body::after {
      /* Soft hills at bottom */
      content: "";
      position: fixed;
      left: -10vw;
      right: -10vw;
      bottom: -20vh;
      height: 50vh;
      background:
        radial-gradient(120% 100% at 10% 80%, #cfe8c9 0 55%, transparent 56%),
        radial-gradient(120% 100% at 55% 90%, #bfe0b8 0 60%, transparent 61%),
        radial-gradient(120% 100% at 95% 85%, #a9d2a2 0 58%, transparent 59%);
      opacity: 0.9;
      pointer-events: none;
      z-index: 0;
      filter: blur(2px);
    }
    header {
      padding: 12px 16px;
      background: linear-gradient(90deg, #0f172a, #1e293b);
      color: #e2e8f0;
      letter-spacing: 0.02em;
      font-weight: 600;
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    header .title { font-size: 18px; }
    header .actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #manual-btn {
      border: none;
      border-radius: 8px;
      padding: 6px 10px;
      background: rgba(147, 197, 253, 0.18);
      color: #e2e8f0;
      font-weight: 600;
      cursor: pointer;
      box-shadow: inset 0 0 0 1px rgba(147, 197, 253, 0.45);
    }
    #manual-btn:hover { background: rgba(147, 197, 253, 0.28); }
    #manual-btn:active { transform: translateY(1px); }
    main {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      padding: 12px;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }
    #stage-wrap {
      position: relative;
      width: 100%;
    }
    #stage {
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      background: linear-gradient(180deg, #e2f0ff 0%, #eef5ff 50%, #d7e6ff 100%);
      width: 100%;
      height: auto;
      display: block;
      aspect-ratio: 16 / 9;
      touch-action: none;
    }
    #panel {
      background: #0f172a;
      color: #e2e8f0;
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    #panel h2 { margin: 0 0 8px 0; font-size: 16px; color: #93c5fd; }
    #panel p { margin: 4px 0; font-size: 13px; line-height: 1.5; }
    code { background: rgba(255,255,255,0.08); padding: 2px 4px; border-radius: 4px; }
    #controls {
      position: absolute;
      left: 8px;
      right: 8px;
      bottom: 8px;
      display: none;
      justify-content: space-between;
      gap: 8px;
      pointer-events: auto;
    }
    #controls .pad, #controls .actions {
      display: flex;
      gap: 8px;
    }
    #controls button {
      width: 56px;
      height: 56px;
      border: none;
      border-radius: 14px;
      background: rgba(15, 23, 42, 0.85);
      color: #e2e8f0;
      font-weight: 700;
      letter-spacing: 0.02em;
      box-shadow: 0 6px 16px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      touch-action: none;
      user-select: none;
    }
    #controls button.active {
      background: #93c5fd;
      color: #0f172a;
      transform: translateY(1px);
    }
    /* Manual modal */
    #manual-modal {
      position: fixed;
      inset: 0;
      display: none;
      z-index: 1000;
    }
    #manual-modal.open { display: block; }
    #manual-modal .backdrop {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(2px);
    }
    #manual-modal .dialog {
      position: relative;
      margin: 8vh auto;
      width: min(520px, 92vw);
      background: #0f172a;
      color: #e2e8f0;
      border-radius: 12px;
      padding: 16px 18px 12px;
      box-shadow: 0 16px 48px rgba(0,0,0,0.5);
    }
    #manual-modal .dialog h2 {
      margin: 0 0 8px 0;
      font-size: 18px;
      color: #93c5fd;
    }
    #manual-modal .dialog p { margin: 6px 0; font-size: 14px; line-height: 1.6; }
    #manual-modal .close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      color: #e2e8f0;
      font-size: 20px;
      cursor: pointer;
    }
    @media (max-width: 900px) {
      main { grid-template-columns: 1fr; }
    }
    @media (hover: none), (pointer: coarse) {
      #controls { display: flex; }
      #panel p { font-size: 14px; }
      header { padding: 10px 12px; }
      #panel { display: none; }
      main {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 0;
        gap: 0;
        height: 100dvh;
      }
      #stage-wrap {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        min-height: 100dvh;
        padding-top: 52px; /* header space */
        padding-bottom: 110px; /* controls space */
        padding-left: 6px;
        padding-right: 6px;
        gap: 0;
      }
      #stage {
        width: 100%;
        height: auto;
        max-height: 100%;
      }
      #controls {
        bottom: calc(8px + env(safe-area-inset-bottom));
      }
      #controls button {
        width: 64px;
        height: 64px;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="title">Youjo Run</div>
    <div class="actions">
      <button id="manual-btn" type="button" aria-haspopup="dialog" aria-controls="manual-modal">Ë™¨ÊòéÊõ∏</button>
    </div>
  </header>
  <main>
    <div id="stage-wrap">
      <canvas id="stage" width="960" height="540"></canvas>
      <div id="controls" aria-label="Touch controls">
        <div class="pad">
          <button id="btn-left" type="button" aria-label="Move left">‚óÄ</button>
          <button id="btn-right" type="button" aria-label="Move right">‚ñ∂</button>
        </div>
        <div class="actions">
          <button id="btn-jump" type="button" aria-label="Jump">Jump</button>
          <button id="btn-rotate" type="button" aria-label="Rotate">Rot</button>
          <button id="btn-sit" type="button" aria-label="Sit">Sit</button>
        </div>
      </div>
    </div>
  </main>

  <div id="manual-modal" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="manual-title">
    <div class="backdrop" data-close></div>
    <div class="dialog" role="document">
      <button class="close" type="button" aria-label="Èñâ„Åò„Çã" data-close>√ó</button>
      <h2 id="manual-title">Êìç‰Ωú</h2>
      <p>A / ‚Üê: Â∑¶„Å´Ëµ∞„Çã</p>
      <p>D / ‚Üí: Âè≥„Å´Ëµ∞„Çã</p>
      <p>W / Space / ‚Üë: „Ç∏„É£„É≥„Éó</p>
      <p>S / ‚Üì: Â∫ß„ÇäÔºàÂ∫ß„Çã‚ÜíÂ∫ß„ÇäÂæÖÊ©üÔºâ</p>
      <p>Z: ÂõûËª¢„É¢„Éº„Ç∑„Éß„É≥</p>
      <p>Âè≥Âêë„Åç„ÅØ„Çπ„Éó„É©„Ç§„Éà„ÇíÊ∞¥Âπ≥ÂèçËª¢„Åó„Å¶ÊèèÁîª„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("stage");
    const ctx = canvas.getContext("2d");

    const frameSize = 256; // source frame size (px)
    const drawScale = 1.0;
    const drawSize = frameSize * drawScale;
    const screenCenterX = canvas.width * 0.5;
    let cameraX = 0;
    const animations = {
      idle:    { src: "spritesheets/idle_sheet.png",    frames: 194, cols: 14, fps: 18, loop: true },
      run:     { src: "spritesheets/run_sheet.png",     frames: 43,  cols: 7,  fps: 22, loop: true },
      jump:    { src: "spritesheets/jump_sheet.png",    frames: 51,  cols: 8,  fps: 30, loop: true }, // 2ÂÄçÈÄü
      rotate:  { src: "spritesheets/rotate_sheet.png",  frames: 47,  cols: 7,  fps: 20, loop: true },
      sit:     { src: "spritesheets/sit_sheet.png",     frames: 39,  cols: 7,  fps: 36, loop: false }, // Á¥Ñ2ÂÄçÈÄü
      sitting: { src: "spritesheets/sitting_sheet.png", frames: 58,  cols: 8,  fps: 12, loop: true },
      rotate:  { src: "spritesheets/rotate_sheet.png",  frames: 47,  cols: 7,  fps: 20, loop: true },
      sit:     { src: "spritesheets/sit_sheet.png",     frames: 39,  cols: 7,  fps: 36, loop: false },
      sitting: { src: "spritesheets/sitting_sheet.png", frames: 58,  cols: 8,  fps: 12, loop: true },
      sleep:   { src: "spritesheets/sleep_sheet.png",   frames: 65,  cols: 9,  fps: 12, loop: false },
    };

    const images = {};
    const keys = { left: false, right: false, jump: false, rotate: false, sit: false };
    const state = {
      action: "idle",
      facing: "left",
      x: canvas.width * 0.5,
      y: canvas.height - 120,
      vy: 0,
      onGround: true,
      frameIdx: 0,
      frameTime: 0,
    };

    let lastInputTime = performance.now();
    const idleSleepMs = 10000;

    let sleepStartTime = 0;
    let lastZzzSpawnTime = 0;
    const zzzSpawnMs = 1200;
    const sleepParticles = [];

    function anyInputActive() {
      return keys.left || keys.right || keys.jump || keys.rotate || keys.sit;
    }

    function registerInput() {
      lastInputTime = performance.now();
    }

    const groundY = canvas.height - 80;
    const gravity = 1800; // px/s^2
    const moveSpeed = 320; // px/s
    const jumpVelocity = -600; // px/s (Â∞ë„ÅóÈ´ò„ÇÅ„Å´Ë™øÊï¥)

    function chromaKeyImage(img, key = [0, 255, 0], tolerance = 250, feather = 40, despill = 0.5) {
      // Replace near-key color with transparent + feather + green despill.
      const c = document.createElement("canvas");
      c.width = img.width;
      c.height = img.height;
      const cctx = c.getContext("2d");
      cctx.drawImage(img, 0, 0);
      const { data } = cctx.getImageData(0, 0, c.width, c.height);
      const tolSq = tolerance * tolerance;
      const softSq = (tolerance + feather) * (tolerance + feather);
      for (let i = 0; i < data.length; i += 4) {
        const dr = data[i] - key[0];
        const dg = data[i + 1] - key[1];
        const db = data[i + 2] - key[2];
        const distSq = dr * dr + dg * dg + db * db;
        if (distSq <= tolSq) {
          data[i + 3] = 0; // hard cut
        } else if (distSq <= softSq) {
          // feather alpha near the edge
          const t = (distSq - tolSq) / (softSq - tolSq);
          data[i + 3] = data[i + 3] * (1 - t);
        }
        // Despill: reduce green halo on remaining pixels.
        const r = data[i], g = data[i + 1], b = data[i + 2];
        const greenDominant = g > r * 1.2 && g > b * 1.2;
        if (greenDominant) {
          const maxOther = Math.max(r, b);
          const newG = Math.max(maxOther, g * (1 - despill));
          data[i + 1] = newG;
        }
      }
      const out = cctx.createImageData(c.width, c.height);
      out.data.set(data);
      cctx.putImageData(out, 0, 0);
      return c;
    }

    function loadImages() {
      return Promise.all(
        Object.entries(animations).map(([key, info]) => new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            images[key] = chromaKeyImage(img, [0, 255, 0], 80);
            resolve();
          };
          img.onerror = reject;
          img.src = info.src;
        }))
      );
    }

    function setAction(action) {
      if (state.action === action) return;
      state.action = action;
      state.frameIdx = 0;
      state.frameTime = 0;
    }

    function handleInput() {
      const movingLeft = keys.left && !keys.right;
      const movingRight = keys.right && !keys.left;

      if (movingLeft) state.facing = "left";
      else if (movingRight) state.facing = "right";

      // Sitting transition
      if (state.onGround && keys.sit && state.action !== "sit") {
        state.vy = 0;
        setAction("sit");
        return;
      }

      // While sit animation is playing, let it finish.
      if (state.action === "sit") return;

      // Sitting idle: break out when moving / jumping / rotating.
      if (state.action === "sitting") {
        if (keys.jump && state.onGround) {
          setAction("jump");
        } else if (keys.rotate && state.onGround) {
          setAction("rotate");
        } else if (movingLeft || movingRight) {
          setAction("run");
        } else {
          setAction("sitting");
        }
        return;
      }

      if (keys.rotate && state.onGround) {
        setAction("rotate");
        return;
      }

      if (!state.onGround) {
        setAction("jump");
        return;
      }

      if (movingLeft || movingRight) setAction("run");
      else setAction("idle");
    }

    function update(delta) {
      const now = performance.now();
      const hasInput = anyInputActive();
      if (hasInput) lastInputTime = now;

      // Sleep after 10s idle, only when grounded.
      if (state.action !== "sleep" && (now - lastInputTime) >= idleSleepMs && state.onGround) {
        setAction("sleep");
        sleepStartTime = now;
        lastZzzSpawnTime = now;
        sleepParticles.length = 0;
      }

      // While sleeping: animate to end, then hold last frame. Wake on input.
      if (state.action === "sleep") {
        const anim = animations[state.action];
        if (hasInput) {
          setAction("idle");
          sleepParticles.length = 0;
        } else {
          const frameDuration = 1 / anim.fps;
          let reachedEnd = false;
          state.frameTime += delta;
          while (state.frameTime >= frameDuration) {
            state.frameTime -= frameDuration;
            if (state.frameIdx < anim.frames - 1) {
              state.frameIdx += 1;
            } else if (anim.loop) {
              state.frameIdx = 0;
            } else {
              reachedEnd = true;
            }
          }
          if (reachedEnd) {
            state.frameIdx = anim.frames - 1;
          }

          // Spawn floating "zzz" once fully asleep.
          if (state.frameIdx >= anim.frames - 1 && now - lastZzzSpawnTime >= zzzSpawnMs) {
            lastZzzSpawnTime = now;
            sleepParticles.push({
              text: "üí§",
              x: screenCenterX + (Math.random() - 0.5) * drawSize * 0.3,
              y: state.y - drawSize * 0.75,
              vx: (Math.random() - 0.5) * 10,
              vy: -20 - Math.random() * 20,
              born: now,
              life: 2200 + Math.random() * 600,
            });
            if (sleepParticles.length > 12) sleepParticles.shift();
          }

          // Update particles
          for (let i = sleepParticles.length - 1; i >= 0; i--) {
            const p = sleepParticles[i];
            const age = now - p.born;
            if (age >= p.life) {
              sleepParticles.splice(i, 1);
              continue;
            }
            p.x += p.vx * delta;
            p.y += p.vy * delta;
            p.vx *= 0.98;
          }

          return;
        }
      }

      handleInput();

      if (state.action !== "sit") {
        if (keys.left && !keys.right) state.x -= moveSpeed * delta;
        else if (keys.right && !keys.left) state.x += moveSpeed * delta;
      }

      // World position is unbounded in both directions.
      cameraX = state.x - screenCenterX;

      if (state.onGround && keys.jump) {
        state.onGround = false;
        state.vy = jumpVelocity;
        setAction("jump");
      }

      if (!state.onGround) {
        state.vy += gravity * delta;
        state.y += state.vy * delta;
        if (state.y >= groundY) {
          state.y = groundY;
          state.vy = 0;
          state.onGround = true;
        }
      } else {
        state.y = groundY;
      }

      const anim = animations[state.action];
      const frameDuration = 1 / anim.fps;
      let reachedEnd = false;
      state.frameTime += delta;
      while (state.frameTime >= frameDuration) {
        state.frameTime -= frameDuration;
        if (state.frameIdx < anim.frames - 1) {
          state.frameIdx += 1;
        } else if (anim.loop) {
          state.frameIdx = 0;
        } else {
          reachedEnd = true;
        }
      }

      if (reachedEnd) {
        state.frameIdx = anim.frames - 1;
        if (state.action === "sit") {
          setAction("sitting");
        }
      }
    }

    function drawBackground(camX) {
      // Cozy pastel sky
      const sky = ctx.createLinearGradient(0, 0, 0, groundY);
      sky.addColorStop(0, "#f7fbff");
      sky.addColorStop(0.6, "#e8f2ff");
      sky.addColorStop(1, "#d7e8ff");
      ctx.fillStyle = sky;
      ctx.fillRect(0, 0, canvas.width, groundY);

      // Sun (emoji) with soft glow
      const sunX = canvas.width * 0.12;
      const sunY = canvas.height * 0.14;
      const sunR = canvas.width * 0.09;
      const sunGlow = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR);
      sunGlow.addColorStop(0, "rgba(255, 245, 200, 0.9)");
      sunGlow.addColorStop(1, "rgba(255, 245, 200, 0)");
      ctx.fillStyle = sunGlow;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
      ctx.fill();
      ctx.font = `${Math.round(sunR * 1.6)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("üåû", sunX, sunY);

      const wrapX = (x, span) => ((x % span) + span) % span;

      // Soft clouds (emoji, slow parallax)
      const cloudSize = canvas.width * 0.08;
      ctx.font = `${Math.round(cloudSize)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const clouds = [
        { x: 0.30, y: 0.18, e: "‚òÅÔ∏è", s: 1.0 },
        { x: 0.70, y: 0.22, e: "‚òÅÔ∏è", s: 1.1 },
        { x: 0.50, y: 0.32, e: "‚òÅÔ∏è", s: 0.95 },
      ];
      for (const c of clouds) {
        const span = canvas.width;
        const baseX = canvas.width * c.x;
        const cxWrapped = wrapX(baseX - camX * 0.3, span);
        const cy = canvas.height * c.y;
        for (const offset of [0, -span]) {
          const cx = cxWrapped + offset;
          ctx.save();
          ctx.translate(cx, cy);
          ctx.scale(c.s, c.s);
          ctx.fillText(c.e, 0, 0);
          ctx.restore();
        }
      }

      // Gentle hills (medium parallax), infinite tiling.
      const hillFactor = 0.5;
      const hillStep = canvas.width;
      const hillViewLeft = camX * hillFactor - hillStep * 2;
      const hillViewRight = camX * hillFactor + canvas.width + hillStep * 2;
      const hillFirst = Math.floor(hillViewLeft / hillStep);
      const hillLast = Math.ceil(hillViewRight / hillStep);
      ctx.fillStyle = "#cfe8c9";
      ctx.beginPath();
      const hillDefs = [
        { x: 0.15, y: 30, rx: 0.35, ry: 0.22 },
        { x: 0.60, y: 40, rx: 0.45, ry: 0.25 },
        { x: 1.05, y: 35, rx: 0.40, ry: 0.23 },
      ];
      for (let k = hillFirst; k <= hillLast; k++) {
        const tileOffset = k * hillStep - camX * hillFactor;
        for (const h of hillDefs) {
          const baseX = canvas.width * h.x;
          const rx = canvas.width * h.rx;
          const ry = canvas.height * h.ry;
          ctx.ellipse(baseX + tileOffset, groundY + h.y, rx, ry, 0, 0, Math.PI * 2);
        }
      }
      ctx.fill();

      const mod = (n, m) => ((n % m) + m) % m;

      // Tree line on the horizon (emoji, medium-fast parallax), stable tiling.
      const treeFactor = 0.6;
      const treeY = groundY - canvas.height * 0.12;
      const treeSize = canvas.width * 0.09;
      ctx.font = `${Math.round(treeSize)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      const trees = ["üå≥", "üå≤", "üå≥", "üå≤", "üå≥"];
      const treeStep = canvas.width * 0.22;
      const treeViewLeft = camX * treeFactor - treeStep * 3;
      const treeViewRight = camX * treeFactor + canvas.width + treeStep * 3;
      const treeFirst = Math.floor(treeViewLeft / treeStep);
      const treeLast = Math.ceil(treeViewRight / treeStep);
      for (let i = treeFirst; i <= treeLast; i++) {
        const tx = i * treeStep - camX * treeFactor;
        ctx.fillText(trees[mod(i, trees.length)], tx, treeY);
      }

      // Ground decorations (emoji, moves with ground), stable tiling.
      const decoFactor = 1.0;
      const decoY = groundY + canvas.height * 0.06;
      const decoSize = canvas.width * 0.045;
      ctx.font = `${Math.round(decoSize)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const decos = ["üåø", "‚òòÔ∏è", "üçÄ", "üåæ", "üå±"];
      const decoStep = canvas.width * 0.14;
      const decoViewLeft = camX * decoFactor - decoStep * 3;
      const decoViewRight = camX * decoFactor + canvas.width + decoStep * 3;
      const decoFirst = Math.floor(decoViewLeft / decoStep);
      const decoLast = Math.ceil(decoViewRight / decoStep);
      for (let i = decoFirst; i <= decoLast; i++) {
        const dx = i * decoStep - camX * decoFactor;
        ctx.fillText(decos[mod(i, decos.length)], dx, decoY);
      }

      // Ground / platform
      const grass = ctx.createLinearGradient(0, groundY, 0, canvas.height);
      grass.addColorStop(0, "#9ad29a");
      grass.addColorStop(1, "#6fbf7a");
      ctx.fillStyle = grass;
      ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

      // Horizon line / ground edge for readability.
      ctx.fillStyle = "rgba(15, 23, 42, 0.35)";
      ctx.fillRect(0, groundY, canvas.width, 10);
      ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
      ctx.fillRect(0, groundY + 10, canvas.width, 3);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground(cameraX);

      const anim = animations[state.action];
      const img = images[state.action];
      if (!img) return;

      const col = state.frameIdx % anim.cols;
      const row = Math.floor(state.frameIdx / anim.cols);
      const sx = col * frameSize;
      const sy = row * frameSize;
      const dx = screenCenterX - drawSize * 0.5;
      const dy = state.y - drawSize;

      ctx.save();
      if (state.facing === "right") {
        ctx.translate(dx + drawSize, dy);
        ctx.scale(-1, 1);
        ctx.drawImage(img, sx, sy, frameSize, frameSize, 0, 0, drawSize, drawSize);
      } else {
        ctx.translate(dx, dy);
        ctx.drawImage(img, sx, sy, frameSize, frameSize, 0, 0, drawSize, drawSize);
      }
      ctx.restore();

      // Sleep text effects
      if (state.action === "sleep") {
        const anim = animations.sleep;
        const progress = anim.frames > 1 ? state.frameIdx / (anim.frames - 1) : 1;

        // "„Åô„ÇÑ„ÅÅ„Éª„Éª„Éª" appears around frame 30, then fades out to the end.
        const suyaaStartFrame = 30;
        if (state.frameIdx >= suyaaStartFrame && state.frameIdx < anim.frames - 1) {
          const tSuyaa = (state.frameIdx - suyaaStartFrame) / (anim.frames - 1 - suyaaStartFrame);
          const alpha = Math.max(0, 1 - tSuyaa);
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.fillStyle = "rgba(15, 23, 42, 0.9)";
          ctx.font = `${Math.round(canvas.width * 0.04)}px sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "bottom";
          const ty = state.y - drawSize * 1.05 - tSuyaa * 20;
          ctx.fillText("„Åô„ÇÑ„ÅÅ„Éª„Éª„Éª", screenCenterX, ty);
          ctx.restore();
        }

        // Floating "zzz"
        ctx.save();
        ctx.fillStyle = "rgba(15, 23, 42, 0.9)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (const p of sleepParticles) {
          const age = performance.now() - p.born;
          const t = Math.min(1, age / p.life);
          const a = 1 - t;
          ctx.globalAlpha = a;
          ctx.font = `${Math.round(canvas.width * 0.05 * (1 + t * 0.25))}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
          ctx.fillText(p.text, p.x, p.y);
        }
        ctx.restore();
      }
    }

    let lastTime = performance.now();
    function loop(time) {
      const delta = Math.min(0.05, (time - lastTime) / 1000);
      lastTime = time;
      update(delta);
      draw();
      requestAnimationFrame(loop);
    }

    window.addEventListener("keydown", (e) => {
      registerInput();
      if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = true;
      if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = true;
      if (e.code === "Space" || e.code === "KeyW" || e.code === "ArrowUp") { keys.jump = true; e.preventDefault(); }
      if (e.code === "KeyZ") keys.rotate = true;
      if (e.code === "KeyS" || e.code === "ArrowDown") keys.sit = true;
    });
    window.addEventListener("keyup", (e) => {
      if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = false;
      if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = false;
      if (e.code === "Space" || e.code === "KeyW" || e.code === "ArrowUp") keys.jump = false;
      if (e.code === "KeyZ") keys.rotate = false;
      if (e.code === "KeyS" || e.code === "ArrowDown") keys.sit = false;
    });

    function bindTouchButton(buttonId, keyName) {
      const btn = document.getElementById(buttonId);
      if (!btn) return;

      const down = (e) => {
        e.preventDefault();
        registerInput();
        keys[keyName] = true;
        btn.classList.add("active");
        try { btn.setPointerCapture(e.pointerId); } catch {}
      };
      const up = (e) => {
        e.preventDefault();
        keys[keyName] = false;
        btn.classList.remove("active");
        try { btn.releasePointerCapture(e.pointerId); } catch {}
      };

      btn.addEventListener("pointerdown", down);
      btn.addEventListener("pointerup", up);
      btn.addEventListener("pointercancel", up);
      btn.addEventListener("pointerleave", up);
      btn.addEventListener("lostpointercapture", up);
    }

    bindTouchButton("btn-left", "left");
    bindTouchButton("btn-right", "right");
    bindTouchButton("btn-jump", "jump");
    bindTouchButton("btn-rotate", "rotate");
    bindTouchButton("btn-sit", "sit");

    const manualBtn = document.getElementById("manual-btn");
    const manualModal = document.getElementById("manual-modal");
    const closeManual = () => {
      if (!manualModal) return;
      manualModal.classList.remove("open");
      manualModal.setAttribute("aria-hidden", "true");
    };
    const openManual = () => {
      if (!manualModal) return;
      manualModal.classList.add("open");
      manualModal.setAttribute("aria-hidden", "false");
      manualModal.querySelector(".close")?.focus();
    };
    manualBtn?.addEventListener("click", openManual);
    manualModal?.addEventListener("click", (e) => {
      const target = e.target;
      if (target instanceof HTMLElement && target.hasAttribute("data-close")) {
        closeManual();
      }
    });
    window.addEventListener("keydown", (e) => {
      if (e.code === "Escape" && manualModal?.classList.contains("open")) closeManual();
    });

    window.addEventListener("blur", () => {
      keys.left = keys.right = keys.jump = keys.rotate = keys.sit = false;
      document.querySelectorAll("#controls button").forEach((b) => b.classList.remove("active"));
    });

    loadImages()
      .then(() => requestAnimationFrame(loop))
      .catch((err) => {
        ctx.fillStyle = "#ef4444";
        ctx.font = "20px sans-serif";
        ctx.fillText("ÁîªÂÉè„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: " + err, 20, 40);
        console.error(err);
      });
  </script>
</body>
</html>
